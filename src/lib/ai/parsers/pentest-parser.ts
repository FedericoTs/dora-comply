/**
 * Penetration Test Report Parser
 *
 * Extracts structured data from penetration testing reports including:
 * - Test scope and methodology
 * - Vulnerabilities found with severity
 * - Remediation recommendations
 * - Maps findings to DORA testing requirements
 */

import { generateText } from 'ai';
import { google } from '@ai-sdk/google';

export const PENTEST_PARSER_VERSION = '1.0.0';
const MODEL = 'gemini-2.0-flash';

// =============================================================================
// Types
// =============================================================================

export type VulnerabilitySeverity = 'critical' | 'high' | 'medium' | 'low' | 'informational';
export type VulnerabilityStatus = 'open' | 'remediated' | 'accepted' | 'false_positive';
export type TestType = 'external' | 'internal' | 'web_application' | 'mobile' | 'api' | 'network' | 'social_engineering' | 'physical' | 'red_team' | 'other';

export interface PentestVulnerability {
  id: string;
  title: string;
  severity: VulnerabilitySeverity;
  cvssScore?: number;
  cvssVector?: string;
  cveIds?: string[];
  cweId?: string;

  // Finding details
  description: string;
  affectedAsset?: string;
  affectedComponent?: string;
  proofOfConcept?: string;

  // Impact
  businessImpact?: string;
  technicalImpact?: string;
  exploitability?: 'trivial' | 'easy' | 'moderate' | 'difficult';

  // Remediation
  remediation: string;
  remediationEffort?: 'low' | 'medium' | 'high';
  remediationPriority?: number;

  // Status
  status: VulnerabilityStatus;
  retestDate?: string;

  // Location
  pageRef?: string;
}

export interface ParsedPentestReport {
  // Test details
  reportTitle: string;
  testerCompany: string;
  testerName?: string;
  testerCertifications?: string[];

  // Scope
  testType: TestType[];
  testStartDate: string;
  testEndDate: string;
  reportDate: string;
  scopeDescription: string;
  targetSystems?: string[];
  excludedSystems?: string[];

  // Methodology
  methodology?: string;
  methodologyStandards?: string[]; // e.g., OWASP, PTES, NIST
  toolsUsed?: string[];

  // Executive summary
  executiveSummary?: string;
  overallRiskRating?: 'critical' | 'high' | 'medium' | 'low';

  // Findings
  vulnerabilities: PentestVulnerability[];

  // Statistics
  totalFindings: number;
  findingsBySeverity: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    informational: number;
  };

  // Retest info
  retestRequired: boolean;
  retestDate?: string;
  retestStatus?: 'pending' | 'scheduled' | 'completed' | 'not_required';

  // DORA Resilience Testing mapping
  doraTestingCoverage: {
    vulnerabilityAssessments: boolean; // Art. 25(1)(a)
    networkSecurity: boolean; // Art. 25(1)(b)
    physicalSecurity: boolean; // Art. 25(1)(c)
    softwareSecurity: boolean; // Art. 25(1)(d)
    penetrationTesting: boolean; // Art. 25(2)
    tlptEligible: boolean; // Art. 26 - Threat-Led Penetration Testing
  };

  // Metadata
  confidenceScore: number;
  parserVersion: string;
  processedAt: string;
  processingTimeMs: number;
}

export interface PentestDatabaseRecord {
  document_id: string;
  tester_company: string;
  test_type: TestType[];
  test_start_date: string;
  test_end_date: string;
  scope_description: string;
  vulnerabilities: PentestVulnerability[];
  findings_by_severity: ParsedPentestReport['findingsBySeverity'];
  dora_testing_coverage: ParsedPentestReport['doraTestingCoverage'];
  raw_extraction: ParsedPentestReport;
  confidence_score: number;
}

export interface PentestParseOptions {
  pdfBuffer: Buffer;
  documentId?: string;
  onProgress?: (message: string, percentage: number) => void;
}

export interface PentestParseResult {
  success: boolean;
  data?: ParsedPentestReport;
  databaseRecord?: PentestDatabaseRecord;
  error?: string;
  processingTimeMs: number;
}

// =============================================================================
// Extraction Prompt
// =============================================================================

const EXTRACTION_PROMPT = `You are an expert penetration tester analyzing a penetration test report.

Extract ALL of the following information from this document:

1. TEST DETAILS:
   - Report title
   - Testing company name
   - Individual tester name(s)
   - Tester certifications (OSCP, CREST, CEH, etc.)
   - Test type(s): external, internal, web_application, mobile, api, network, social_engineering, physical, red_team
   - Test dates (start and end)
   - Report date

2. SCOPE:
   - Scope description
   - Target systems/applications
   - Excluded systems
   - IP ranges or URLs tested

3. METHODOLOGY:
   - Testing methodology used
   - Standards followed (OWASP, PTES, NIST, etc.)
   - Tools used

4. EXECUTIVE SUMMARY:
   - Overall risk rating
   - Key findings summary

5. VULNERABILITIES (Extract ALL findings):
   For each vulnerability:
   - ID/Reference number
   - Title
   - Severity (critical, high, medium, low, informational)
   - CVSS score and vector (if provided)
   - CVE IDs (if referenced)
   - CWE ID (if referenced)
   - Description
   - Affected asset/system
   - Proof of concept
   - Business impact
   - Technical impact
   - Remediation recommendation
   - Remediation effort (low, medium, high)
   - Status (open, remediated, accepted, false_positive)

6. RETEST INFORMATION:
   - Is retest required?
   - Scheduled retest date
   - Retest status

RESPOND WITH ONLY VALID JSON:
{
  "testDetails": {
    "reportTitle": "Penetration Test Report",
    "testerCompany": "Security Corp",
    "testerName": "John Smith",
    "testerCertifications": ["OSCP", "CREST"],
    "testType": ["external", "web_application"],
    "testStartDate": "YYYY-MM-DD",
    "testEndDate": "YYYY-MM-DD",
    "reportDate": "YYYY-MM-DD"
  },
  "scope": {
    "scopeDescription": "External penetration test of...",
    "targetSystems": ["app.example.com", "api.example.com"],
    "excludedSystems": ["staging.example.com"],
    "methodology": "OWASP Testing Guide v4",
    "methodologyStandards": ["OWASP", "PTES"],
    "toolsUsed": ["Burp Suite", "Nmap", "Metasploit"]
  },
  "executive": {
    "executiveSummary": "Overall risk is HIGH...",
    "overallRiskRating": "high"
  },
  "vulnerabilities": [
    {
      "id": "VULN-001",
      "title": "SQL Injection in Login Form",
      "severity": "critical",
      "cvssScore": 9.8,
      "cvssVector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "cveIds": ["CVE-2021-12345"],
      "cweId": "CWE-89",
      "description": "SQL injection vulnerability allows...",
      "affectedAsset": "login.example.com",
      "affectedComponent": "/api/auth/login",
      "proofOfConcept": "Parameter 'username' is vulnerable...",
      "businessImpact": "Complete database compromise possible",
      "technicalImpact": "Authentication bypass, data exfiltration",
      "exploitability": "easy",
      "remediation": "Use parameterized queries...",
      "remediationEffort": "medium",
      "remediationPriority": 1,
      "status": "open",
      "pageRef": "Page 15"
    }
  ],
  "retest": {
    "retestRequired": true,
    "retestDate": "YYYY-MM-DD",
    "retestStatus": "scheduled"
  },
  "stats": {
    "totalFindings": 12,
    "critical": 2,
    "high": 4,
    "medium": 3,
    "low": 2,
    "informational": 1
  }
}`;

// =============================================================================
// Parser Function
// =============================================================================

export async function parsePentestReport(
  options: PentestParseOptions
): Promise<PentestParseResult> {
  const startTime = Date.now();
  const { pdfBuffer, documentId, onProgress } = options;

  try {
    onProgress?.('Starting penetration test report extraction...', 5);

    const pdfBase64 = pdfBuffer.toString('base64');

    onProgress?.('Sending report to AI for analysis...', 15);

    const result = await generateText({
      model: google(MODEL),
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'file',
              data: pdfBase64,
              mediaType: 'application/pdf',
            },
            {
              type: 'text',
              text: EXTRACTION_PROMPT,
            },
          ],
        },
      ],
      maxOutputTokens: 16384,
      temperature: 0,
    });

    onProgress?.('Parsing AI response...', 70);

    // Parse JSON response
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in AI response');
    }

    const parsed = JSON.parse(jsonMatch[0]);

    onProgress?.('Processing extracted data...', 80);

    // Build vulnerabilities array
    const vulnerabilities: PentestVulnerability[] = (parsed.vulnerabilities || []).map(
      (v: Record<string, unknown>) => ({
        id: v.id as string || `VULN-${Math.random().toString(36).slice(2, 8)}`,
        title: v.title as string || 'Unknown Vulnerability',
        severity: (v.severity as VulnerabilitySeverity) || 'medium',
        cvssScore: v.cvssScore as number | undefined,
        cvssVector: v.cvssVector as string | undefined,
        cveIds: v.cveIds as string[] | undefined,
        cweId: v.cweId as string | undefined,
        description: v.description as string || '',
        affectedAsset: v.affectedAsset as string | undefined,
        affectedComponent: v.affectedComponent as string | undefined,
        proofOfConcept: v.proofOfConcept as string | undefined,
        businessImpact: v.businessImpact as string | undefined,
        technicalImpact: v.technicalImpact as string | undefined,
        exploitability: v.exploitability as PentestVulnerability['exploitability'],
        remediation: v.remediation as string || 'Remediation not specified',
        remediationEffort: v.remediationEffort as PentestVulnerability['remediationEffort'],
        remediationPriority: v.remediationPriority as number | undefined,
        status: (v.status as VulnerabilityStatus) || 'open',
        retestDate: v.retestDate as string | undefined,
        pageRef: v.pageRef as string | undefined,
      })
    );

    onProgress?.('Calculating DORA testing coverage...', 90);

    const testDetails = parsed.testDetails || {};
    const scope = parsed.scope || {};
    const executive = parsed.executive || {};
    const retest = parsed.retest || {};
    const stats = parsed.stats || {};

    // Calculate findings by severity
    const findingsBySeverity = {
      critical: stats.critical || vulnerabilities.filter(v => v.severity === 'critical').length,
      high: stats.high || vulnerabilities.filter(v => v.severity === 'high').length,
      medium: stats.medium || vulnerabilities.filter(v => v.severity === 'medium').length,
      low: stats.low || vulnerabilities.filter(v => v.severity === 'low').length,
      informational: stats.informational || vulnerabilities.filter(v => v.severity === 'informational').length,
    };

    // Calculate DORA testing coverage
    const testTypes = (testDetails.testType as TestType[]) || [];
    const doraTestingCoverage = calculateDORATestingCoverage(testTypes, scope);

    const parsedReport: ParsedPentestReport = {
      reportTitle: testDetails.reportTitle || 'Penetration Test Report',
      testerCompany: testDetails.testerCompany || 'Unknown',
      testerName: testDetails.testerName,
      testerCertifications: testDetails.testerCertifications,

      testType: testTypes,
      testStartDate: testDetails.testStartDate || '',
      testEndDate: testDetails.testEndDate || '',
      reportDate: testDetails.reportDate || '',
      scopeDescription: scope.scopeDescription || '',
      targetSystems: scope.targetSystems,
      excludedSystems: scope.excludedSystems,

      methodology: scope.methodology,
      methodologyStandards: scope.methodologyStandards,
      toolsUsed: scope.toolsUsed,

      executiveSummary: executive.executiveSummary,
      overallRiskRating: executive.overallRiskRating,

      vulnerabilities,
      totalFindings: vulnerabilities.length,
      findingsBySeverity,

      retestRequired: retest.retestRequired || findingsBySeverity.critical > 0 || findingsBySeverity.high > 0,
      retestDate: retest.retestDate,
      retestStatus: retest.retestStatus,

      doraTestingCoverage,

      confidenceScore: vulnerabilities.length > 0 ? 0.9 : 0.7,
      parserVersion: PENTEST_PARSER_VERSION,
      processedAt: new Date().toISOString(),
      processingTimeMs: Date.now() - startTime,
    };

    onProgress?.(`Extraction complete! Found ${vulnerabilities.length} vulnerabilities.`, 100);

    // Build database record
    const databaseRecord: PentestDatabaseRecord | undefined = documentId
      ? {
          document_id: documentId,
          tester_company: parsedReport.testerCompany,
          test_type: parsedReport.testType,
          test_start_date: parsedReport.testStartDate,
          test_end_date: parsedReport.testEndDate,
          scope_description: parsedReport.scopeDescription,
          vulnerabilities: parsedReport.vulnerabilities,
          findings_by_severity: parsedReport.findingsBySeverity,
          dora_testing_coverage: parsedReport.doraTestingCoverage,
          raw_extraction: parsedReport,
          confidence_score: parsedReport.confidenceScore,
        }
      : undefined;

    return {
      success: true,
      data: parsedReport,
      databaseRecord,
      processingTimeMs: Date.now() - startTime,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('[Pentest Parser] Error:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      processingTimeMs: Date.now() - startTime,
    };
  }
}

// =============================================================================
// DORA Testing Coverage Calculation
// =============================================================================

/**
 * Map pentest type to DORA Article 25-26 testing requirements
 */
function calculateDORATestingCoverage(
  testTypes: TestType[],
  scope: Record<string, unknown>
): ParsedPentestReport['doraTestingCoverage'] {
  const coverage = {
    vulnerabilityAssessments: false, // Art. 25(1)(a)
    networkSecurity: false, // Art. 25(1)(b)
    physicalSecurity: false, // Art. 25(1)(c)
    softwareSecurity: false, // Art. 25(1)(d)
    penetrationTesting: false, // Art. 25(2)
    tlptEligible: false, // Art. 26 - TLPT
  };

  // Any pentest counts as penetration testing
  if (testTypes.length > 0) {
    coverage.penetrationTesting = true;
  }

  // Map test types to DORA requirements
  for (const testType of testTypes) {
    switch (testType) {
      case 'network':
      case 'external':
      case 'internal':
        coverage.vulnerabilityAssessments = true;
        coverage.networkSecurity = true;
        break;
      case 'web_application':
      case 'api':
      case 'mobile':
        coverage.vulnerabilityAssessments = true;
        coverage.softwareSecurity = true;
        break;
      case 'physical':
        coverage.physicalSecurity = true;
        break;
      case 'red_team':
        coverage.vulnerabilityAssessments = true;
        coverage.networkSecurity = true;
        coverage.softwareSecurity = true;
        coverage.tlptEligible = true; // Red team tests may qualify as TLPT
        break;
      case 'social_engineering':
        coverage.vulnerabilityAssessments = true;
        break;
    }
  }

  // Check methodology for TLPT eligibility
  const methodology = (scope.methodology as string || '').toLowerCase();
  const standards = (scope.methodologyStandards as string[] || []).map(s => s.toLowerCase());

  if (
    methodology.includes('tlpt') ||
    methodology.includes('threat-led') ||
    methodology.includes('tiber') ||
    standards.includes('tiber-eu') ||
    standards.includes('cbest') ||
    standards.includes('icast')
  ) {
    coverage.tlptEligible = true;
  }

  return coverage;
}

// =============================================================================
// Severity Utilities
// =============================================================================

export function getSeverityColor(severity: VulnerabilitySeverity): string {
  switch (severity) {
    case 'critical':
      return 'bg-destructive text-destructive-foreground';
    case 'high':
      return 'bg-red-500 text-white';
    case 'medium':
      return 'bg-orange-500 text-white';
    case 'low':
      return 'bg-yellow-500 text-black';
    case 'informational':
      return 'bg-blue-500 text-white';
    default:
      return 'bg-gray-500 text-white';
  }
}

export function getSeverityWeight(severity: VulnerabilitySeverity): number {
  switch (severity) {
    case 'critical':
      return 10;
    case 'high':
      return 7;
    case 'medium':
      return 4;
    case 'low':
      return 2;
    case 'informational':
      return 0.5;
    default:
      return 1;
  }
}

/**
 * Calculate overall risk score from vulnerabilities (0-100)
 */
export function calculatePentestRiskScore(vulnerabilities: PentestVulnerability[]): number {
  if (vulnerabilities.length === 0) return 0;

  let totalWeight = 0;
  let maxPossible = vulnerabilities.length * 10; // Max if all critical

  for (const vuln of vulnerabilities) {
    if (vuln.status === 'remediated' || vuln.status === 'false_positive') {
      continue; // Don't count remediated/false positives
    }
    totalWeight += getSeverityWeight(vuln.severity);
  }

  const score = Math.min(100, Math.round((totalWeight / maxPossible) * 100));
  return score;
}
