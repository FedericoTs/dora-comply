/**
 * Resilience Testing Queries
 *
 * Database operations for DORA Chapter IV resilience testing
 * Articles 24-27: Testing programmes, tests, findings, TLPT
 */

import { createClient } from '@/lib/supabase/server';
import {
  TEST_TYPES,
  getTLPTComplianceStatus,
  getDaysUntilDue,
} from './types';
import type {
  TestingProgramme,
  TestingProgrammeWithStats,
  ResilienceTest,
  ResilienceTestWithRelations,
  TestListItem,
  TestFinding,
  TLPTEngagement,
  TLPTEngagementWithRelations,
  TLPTListItem,
  TestingDocument,
  TestFilters,
  FindingFilters,
  TLPTFilters,
  TestingStats,
  OpenFindingSummary,
  CreateProgrammeInput,
  UpdateProgrammeInput,
  CreateTestInput,
  UpdateTestInput,
  CreateFindingInput,
  UpdateFindingInput,
  CreateTLPTInput,
  UpdateTLPTInput,
  TestType,
} from './types';

// ============================================================================
// Testing Programmes
// ============================================================================

export async function getProgrammes(
  year?: number
): Promise<{ data: TestingProgrammeWithStats[]; error: string | null }> {
  const supabase = await createClient();

  let query = supabase
    .from('testing_programme_stats')
    .select('*')
    .order('year', { ascending: false });

  if (year) {
    query = query.eq('year', year);
  }

  const { data, error } = await query;

  if (error) {
    console.error('[Testing] Get programmes error:', error);
    return { data: [], error: error.message };
  }

  return { data: data as TestingProgrammeWithStats[], error: null };
}

export async function getProgrammeById(
  id: string
): Promise<{ data: TestingProgrammeWithStats | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('testing_programme_stats')
    .select('*')
    .eq('programme_id', id)
    .single();

  if (error) {
    console.error('[Testing] Get programme error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestingProgrammeWithStats, error: null };
}

export async function createProgramme(
  input: CreateProgrammeInput
): Promise<{ data: TestingProgramme | null; error: string | null }> {
  const supabase = await createClient();

  // Get current user and organization
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return { data: null, error: 'Authentication required' };
  }

  const { data: userData } = await supabase
    .from('users')
    .select('organization_id')
    .eq('id', user.id)
    .single();

  if (!userData?.organization_id) {
    return { data: null, error: 'Organization not found' };
  }

  const { data, error } = await supabase
    .from('testing_programmes')
    .insert({
      organization_id: userData.organization_id,
      created_by: user.id,
      status: 'draft',
      programme_ref: '', // Will be auto-generated by trigger
      ...input,
    })
    .select()
    .single();

  if (error) {
    console.error('[Testing] Create programme error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestingProgramme, error: null };
}

export async function updateProgramme(
  id: string,
  input: UpdateProgrammeInput
): Promise<{ data: TestingProgramme | null; error: string | null }> {
  const supabase = await createClient();

  // If approving, set approval date and user
  let updates: Record<string, unknown> = { ...input };
  if (input.status === 'approved') {
    const { data: { user } } = await supabase.auth.getUser();
    updates = {
      ...updates,
      approval_date: new Date().toISOString().split('T')[0],
      approved_by: user?.id,
    };
  }

  const { data, error } = await supabase
    .from('testing_programmes')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    console.error('[Testing] Update programme error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestingProgramme, error: null };
}

export async function deleteProgramme(
  id: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('testing_programmes')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('[Testing] Delete programme error:', error);
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

// ============================================================================
// Resilience Tests
// ============================================================================

export async function getTests(
  filters?: TestFilters
): Promise<{ data: TestListItem[]; count: number; error: string | null }> {
  const supabase = await createClient();

  let query = supabase
    .from('resilience_tests')
    .select(`
      id,
      test_ref,
      name,
      test_type,
      status,
      overall_result,
      planned_start_date,
      actual_end_date,
      findings_count,
      critical_findings_count,
      programme:testing_programmes(name),
      vendor:vendors(name)
    `, { count: 'exact' });

  // Apply filters
  if (filters?.status) {
    const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
    query = query.in('status', statuses);
  }

  if (filters?.test_type) {
    const types = Array.isArray(filters.test_type) ? filters.test_type : [filters.test_type];
    query = query.in('test_type', types);
  }

  if (filters?.programme_id) {
    query = query.eq('programme_id', filters.programme_id);
  }

  if (filters?.vendor_id) {
    query = query.eq('vendor_id', filters.vendor_id);
  }

  if (filters?.date_from) {
    query = query.gte('planned_start_date', filters.date_from);
  }

  if (filters?.date_to) {
    query = query.lte('planned_start_date', filters.date_to);
  }

  if (filters?.search) {
    query = query.or(`name.ilike.%${filters.search}%,test_ref.ilike.%${filters.search}%`);
  }

  query = query.order('created_at', { ascending: false });

  const { data, error, count } = await query;

  if (error) {
    console.error('[Testing] Get tests error:', error);
    return { data: [], count: 0, error: error.message };
  }

  // Transform to list items
  const listItems: TestListItem[] = (data || []).map((test) => {
    const programmeData = test.programme;
    const programme = Array.isArray(programmeData)
      ? (programmeData[0] as { name: string } | undefined)
      : (programmeData as { name: string } | null);

    const vendorData = test.vendor;
    const vendor = Array.isArray(vendorData)
      ? (vendorData[0] as { name: string } | undefined)
      : (vendorData as { name: string } | null);

    return {
      id: test.id,
      test_ref: test.test_ref,
      name: test.name,
      test_type: test.test_type,
      status: test.status,
      overall_result: test.overall_result,
      planned_start_date: test.planned_start_date,
      actual_end_date: test.actual_end_date,
      findings_count: test.findings_count,
      critical_findings_count: test.critical_findings_count,
      programme_name: programme?.name || null,
      vendor_name: vendor?.name || null,
    };
  });

  return { data: listItems, count: count || 0, error: null };
}

export async function getTestById(
  id: string
): Promise<{ data: ResilienceTestWithRelations | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('resilience_tests')
    .select(`
      *,
      programme:testing_programmes(id, name, programme_ref),
      vendor:vendors(id, name, lei),
      findings:test_findings(*)
    `)
    .eq('id', id)
    .single();

  if (error) {
    console.error('[Testing] Get test error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as ResilienceTestWithRelations, error: null };
}

export async function createTest(
  input: CreateTestInput
): Promise<{ data: ResilienceTest | null; error: string | null }> {
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return { data: null, error: 'Authentication required' };
  }

  const { data: userData } = await supabase
    .from('users')
    .select('organization_id')
    .eq('id', user.id)
    .single();

  if (!userData?.organization_id) {
    return { data: null, error: 'Organization not found' };
  }

  const { data, error } = await supabase
    .from('resilience_tests')
    .insert({
      organization_id: userData.organization_id,
      created_by: user.id,
      test_ref: '', // Auto-generated by trigger
      status: 'planned',
      ...input,
    })
    .select()
    .single();

  if (error) {
    console.error('[Testing] Create test error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as ResilienceTest, error: null };
}

export async function updateTest(
  id: string,
  input: UpdateTestInput
): Promise<{ data: ResilienceTest | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('resilience_tests')
    .update({
      ...input,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    console.error('[Testing] Update test error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as ResilienceTest, error: null };
}

export async function deleteTest(
  id: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('resilience_tests')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('[Testing] Delete test error:', error);
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

// ============================================================================
// Test Findings
// ============================================================================

export async function getFindings(
  filters?: FindingFilters
): Promise<{ data: TestFinding[]; count: number; error: string | null }> {
  const supabase = await createClient();

  let query = supabase
    .from('test_findings')
    .select('*', { count: 'exact' });

  if (filters?.test_id) {
    query = query.eq('test_id', filters.test_id);
  }

  if (filters?.severity) {
    const severities = Array.isArray(filters.severity) ? filters.severity : [filters.severity];
    query = query.in('severity', severities);
  }

  if (filters?.status) {
    const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
    query = query.in('status', statuses);
  }

  if (filters?.search) {
    query = query.or(`title.ilike.%${filters.search}%,finding_ref.ilike.%${filters.search}%,description.ilike.%${filters.search}%`);
  }

  query = query.order('created_at', { ascending: false });

  const { data, error, count } = await query;

  if (error) {
    console.error('[Testing] Get findings error:', error);
    return { data: [], count: 0, error: error.message };
  }

  return { data: data as TestFinding[], count: count || 0, error: null };
}

export async function getFindingById(
  id: string
): Promise<{ data: TestFinding | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('test_findings')
    .select('*')
    .eq('id', id)
    .single();

  if (error) {
    console.error('[Testing] Get finding error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestFinding, error: null };
}

export async function createFinding(
  input: CreateFindingInput
): Promise<{ data: TestFinding | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('test_findings')
    .insert({
      finding_ref: '', // Auto-generated by trigger
      status: 'open',
      ...input,
    })
    .select()
    .single();

  if (error) {
    console.error('[Testing] Create finding error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestFinding, error: null };
}

export async function updateFinding(
  id: string,
  input: UpdateFindingInput
): Promise<{ data: TestFinding | null; error: string | null }> {
  const supabase = await createClient();

  // Handle status transitions
  let updates: Record<string, unknown> = { ...input };

  // If setting to verified, capture who verified it
  if (input.status === 'verified') {
    const { data: { user } } = await supabase.auth.getUser();
    updates = {
      ...updates,
      verified_by: user?.id,
      verified_date: new Date().toISOString().split('T')[0],
    };
  }

  // If accepting risk, capture approval
  if (input.status === 'risk_accepted') {
    const { data: { user } } = await supabase.auth.getUser();
    updates = {
      ...updates,
      risk_acceptance_approved_by: user?.id,
      risk_acceptance_date: new Date().toISOString().split('T')[0],
    };
  }

  const { data, error } = await supabase
    .from('test_findings')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    console.error('[Testing] Update finding error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestFinding, error: null };
}

export async function deleteFinding(
  id: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('test_findings')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('[Testing] Delete finding error:', error);
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

// ============================================================================
// TLPT Engagements
// ============================================================================

export async function getTLPTEngagements(
  filters?: TLPTFilters
): Promise<{ data: TLPTListItem[]; count: number; error: string | null }> {
  const supabase = await createClient();

  let query = supabase
    .from('tlpt_engagements')
    .select('id, tlpt_ref, name, framework, status, next_tlpt_due', { count: 'exact' });

  if (filters?.status) {
    const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
    query = query.in('status', statuses);
  }

  if (filters?.framework) {
    const frameworks = Array.isArray(filters.framework) ? filters.framework : [filters.framework];
    query = query.in('framework', frameworks);
  }

  if (filters?.programme_id) {
    query = query.eq('programme_id', filters.programme_id);
  }

  query = query.order('created_at', { ascending: false });

  const { data, error, count } = await query;

  if (error) {
    console.error('[Testing] Get TLPT error:', error);
    return { data: [], count: 0, error: error.message };
  }

  // Transform with compliance status
  const listItems: TLPTListItem[] = (data || []).map((tlpt) => ({
    id: tlpt.id,
    tlpt_ref: tlpt.tlpt_ref,
    name: tlpt.name,
    framework: tlpt.framework,
    status: tlpt.status,
    next_tlpt_due: tlpt.next_tlpt_due,
    compliance_status: getTLPTComplianceStatus(tlpt.next_tlpt_due),
    days_until_due: getDaysUntilDue(tlpt.next_tlpt_due),
  }));

  // Filter by compliance status if specified
  let filteredItems = listItems;
  if (filters?.compliance_status) {
    filteredItems = listItems.filter(t => t.compliance_status === filters.compliance_status);
  }

  return { data: filteredItems, count: count || 0, error: null };
}

export async function getTLPTById(
  id: string
): Promise<{ data: TLPTEngagementWithRelations | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('tlpt_engagements')
    .select(`
      *,
      programme:testing_programmes(id, name, programme_ref)
    `)
    .eq('id', id)
    .single();

  if (error) {
    console.error('[Testing] Get TLPT error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TLPTEngagementWithRelations, error: null };
}

export async function createTLPT(
  input: CreateTLPTInput
): Promise<{ data: TLPTEngagement | null; error: string | null }> {
  const supabase = await createClient();

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return { data: null, error: 'Authentication required' };
  }

  const { data: userData } = await supabase
    .from('users')
    .select('organization_id')
    .eq('id', user.id)
    .single();

  if (!userData?.organization_id) {
    return { data: null, error: 'Organization not found' };
  }

  const { data, error } = await supabase
    .from('tlpt_engagements')
    .insert({
      organization_id: userData.organization_id,
      created_by: user.id,
      tlpt_ref: '', // Auto-generated by trigger
      status: 'planning',
      framework: input.framework || 'tiber_eu',
      ...input,
    })
    .select()
    .single();

  if (error) {
    console.error('[Testing] Create TLPT error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TLPTEngagement, error: null };
}

export async function updateTLPT(
  id: string,
  input: UpdateTLPTInput
): Promise<{ data: TLPTEngagement | null; error: string | null }> {
  const supabase = await createClient();

  // If completing, set last_tlpt_date and calculate next due
  let updates: Record<string, unknown> = { ...input };
  if (input.status === 'completed') {
    const today = new Date().toISOString().split('T')[0];
    const nextDue = new Date();
    nextDue.setFullYear(nextDue.getFullYear() + 3);
    updates = {
      ...updates,
      last_tlpt_date: today,
      next_tlpt_due: nextDue.toISOString().split('T')[0],
    };
  }

  const { data, error } = await supabase
    .from('tlpt_engagements')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    console.error('[Testing] Update TLPT error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TLPTEngagement, error: null };
}

export async function deleteTLPT(
  id: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('tlpt_engagements')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('[Testing] Delete TLPT error:', error);
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

// ============================================================================
// Testing Documents
// ============================================================================

export async function getTestingDocuments(
  entityId: string,
  entityType: 'test' | 'tlpt' | 'programme'
): Promise<{ data: TestingDocument[]; error: string | null }> {
  const supabase = await createClient();

  let query = supabase
    .from('testing_documents')
    .select(`
      *,
      document:documents(id, name, file_path, file_type, file_size)
    `);

  if (entityType === 'test') {
    query = query.eq('test_id', entityId);
  } else if (entityType === 'tlpt') {
    query = query.eq('tlpt_id', entityId);
  } else {
    query = query.eq('programme_id', entityId);
  }

  const { data, error } = await query.order('created_at', { ascending: false });

  if (error) {
    console.error('[Testing] Get documents error:', error);
    return { data: [], error: error.message };
  }

  return { data: data as TestingDocument[], error: null };
}

export async function linkTestingDocument(
  documentId: string,
  entityId: string,
  entityType: 'test' | 'tlpt' | 'programme',
  documentType: string,
  description?: string
): Promise<{ data: TestingDocument | null; error: string | null }> {
  const supabase = await createClient();

  const { data: { user } } = await supabase.auth.getUser();

  const insertData: Record<string, unknown> = {
    document_id: documentId,
    document_type: documentType,
    description,
    uploaded_by: user?.id,
  };

  if (entityType === 'test') {
    insertData.test_id = entityId;
  } else if (entityType === 'tlpt') {
    insertData.tlpt_id = entityId;
  } else {
    insertData.programme_id = entityId;
  }

  const { data, error } = await supabase
    .from('testing_documents')
    .insert(insertData)
    .select()
    .single();

  if (error) {
    console.error('[Testing] Link document error:', error);
    return { data: null, error: error.message };
  }

  return { data: data as TestingDocument, error: null };
}

export async function unlinkTestingDocument(
  id: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('testing_documents')
    .delete()
    .eq('id', id);

  if (error) {
    console.error('[Testing] Unlink document error:', error);
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

// ============================================================================
// Statistics & Dashboard
// ============================================================================

export async function getTestingStats(): Promise<{ data: TestingStats | null; error: string | null }> {
  const supabase = await createClient();

  // Get programmes
  const { data: programmes } = await supabase
    .from('testing_programmes')
    .select('status');

  // Get tests
  const { data: tests } = await supabase
    .from('resilience_tests')
    .select('status, test_type, actual_end_date');

  // Get open findings
  const { data: openFindings } = await supabase
    .from('open_findings_summary')
    .select('*');

  // Get TLPT compliance
  const { data: tlptStatus } = await supabase
    .from('tlpt_compliance_status')
    .select('compliance_status');

  // Calculate stats
  const currentYear = new Date().getFullYear();

  const stats: TestingStats = {
    active_programmes: programmes?.filter(p => p.status === 'active').length || 0,
    total_programmes: programmes?.length || 0,
    total_tests: tests?.length || 0,
    tests_by_status: {
      planned: 0,
      scheduled: 0,
      in_progress: 0,
      completed: 0,
      cancelled: 0,
      on_hold: 0,
      remediation_required: 0,
    },
    tests_by_type: {} as Record<TestType, number>,
    completed_tests_this_year: 0,
    open_findings: 0,
    critical_open_findings: 0,
    findings_by_severity: {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      informational: 0,
    },
    overdue_remediations: 0,
    active_tlpt: 0,
    tlpt_due_soon: 0,
    tlpt_overdue: 0,
    test_type_coverage: 0,
  };

  // Initialize test types
  for (const type of TEST_TYPES) {
    stats.tests_by_type[type] = 0;
  }

  // Aggregate test stats
  const completedTestTypes = new Set<TestType>();
  for (const test of tests || []) {
    stats.tests_by_status[test.status as keyof typeof stats.tests_by_status]++;
    stats.tests_by_type[test.test_type as TestType]++;

    // Check if completed this year
    if (test.status === 'completed' && test.actual_end_date) {
      const endYear = new Date(test.actual_end_date).getFullYear();
      if (endYear === currentYear) {
        stats.completed_tests_this_year++;
        completedTestTypes.add(test.test_type as TestType);
      }
    }
  }

  // Calculate test type coverage
  stats.test_type_coverage = Math.round((completedTestTypes.size / TEST_TYPES.length) * 100);

  // Aggregate finding stats
  for (const finding of openFindings || []) {
    const count = Number(finding.finding_count) || 0;
    const overdueCount = Number(finding.overdue_count) || 0;
    stats.open_findings += count;
    stats.overdue_remediations += overdueCount;
    stats.findings_by_severity[finding.severity as keyof typeof stats.findings_by_severity] = count;

    if (finding.severity === 'critical') {
      stats.critical_open_findings = count;
    }
  }

  // Aggregate TLPT stats
  for (const tlpt of tlptStatus || []) {
    if (tlpt.compliance_status === 'overdue') {
      stats.tlpt_overdue++;
    } else if (tlpt.compliance_status === 'due_soon') {
      stats.tlpt_due_soon++;
    }
    // Count active (non-completed, non-cancelled)
    stats.active_tlpt++;
  }

  return { data: stats, error: null };
}

export async function getOpenFindingsSummary(): Promise<{ data: OpenFindingSummary[]; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('open_findings_summary')
    .select('*');

  if (error) {
    console.error('[Testing] Get open findings summary error:', error);
    return { data: [], error: error.message };
  }

  return {
    data: (data || []).map(row => ({
      severity: row.severity,
      count: Number(row.finding_count) || 0,
      overdue_count: Number(row.overdue_count) || 0,
    })),
    error: null
  };
}

// ============================================================================
// Helpers for Forms
// ============================================================================

export async function getProgrammesForSelect(): Promise<{ data: Array<{ id: string; name: string; programme_ref: string }>; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('testing_programmes')
    .select('id, name, programme_ref')
    .in('status', ['approved', 'active'])
    .order('year', { ascending: false });

  if (error) {
    return { data: [], error: error.message };
  }

  return { data: data || [], error: null };
}

export async function getVendorsForSelect(): Promise<{ data: Array<{ id: string; name: string }>; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('vendors')
    .select('id, name')
    .order('name');

  if (error) {
    return { data: [], error: error.message };
  }

  return { data: data || [], error: null };
}

export async function getTestsForSelect(): Promise<{ data: Array<{ id: string; name: string; test_ref: string }>; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('resilience_tests')
    .select('id, name, test_ref')
    .order('created_at', { ascending: false });

  if (error) {
    return { data: [], error: error.message };
  }

  return { data: data || [], error: null };
}
